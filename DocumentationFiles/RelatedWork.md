# Related Work

The problem of a good simulation framework is that there must be a lot of possibilities to modify the simulator for new test case and give evaluation information as much and detailed output. There are existing much simulator for different specific scenario. For example the SUMO \cite{sumo} simulator simulate traffic in an urban area. SUMO can be used to test traffic light control algorithms to get the best light control system for a city. It takes therefor respect to traffic tips which can be controlled with characteristics. UdelModels \cite{udelmodels} is another simulation framework for urban networks. It take care on realistic propagation and gives a user interface for city creation. The OMNeT++ \cite{omnet} simulation sweet includes different tool and simulates network protocols in varying areas.

For our simulator we use Siafu \cite{Siafu} time simulation framework. Siafu provides random walk algorithms on a basic map and has a user interface to observe all agents with there actual states. Because of the open source code and its implementation in java we use it in our application. It is possible to easily change the map on which the agents work and we expand Siafu with a new robot architecture behind to simulate various arts of robots and algorithms.

There are although other simulators like Siafu for example JAS \cite{jas}. JAS is implemented in JAVA and gets his complete functional scope from third party libraries. It represents agents in components and brings a variety of collections from components and rules for the simulation.

For the knowledge exchange different strategies could be used. For example the FIPA \cite{fipa} produces software specifications for multi-agent systems like communication protocols to maximize the compatibility of MAS. JADE \cite{jade} for example is an  platform for peer-to-peer agent based applications. It describes a middleware which uses the FIPA specifications for the communication between agents. Therefor it provide a graphic tool and facilitate the troubleshooting and deployment phase of the system. The platform is implemented in JAVA and could be used to realize different kinds of agent architectures. In the background for the representation of a agent it uses containers. The commercial tool is JACK \cite{jack} which is although implemented in java. JACK is developed from the Agent Oriented Software Pty, Ltd. (AOS) and is a progression of the Procedural Reasoning System (PRS) and the Distributed Multi-Agent Reasoning System (dMARS). As JADE it helps to create MAS. Every agent works in JACK in accordance with the BDI (Belief, Desire and Intentions) principle, which say that every agent can be described with its goals, his knowledge and his social skills and acts from the environmental input.

For our simulator we use only a simple information exchange based on the real data objects. To get a some various exchange strategies we look on the paper of Götz et al. \cite{datenaustausch} where three different strategies are mentioned. This are the total exchange strategy where all agents collaborate with each other and exchange there complete knowledge. Then the partial complete method where each subsystem exchange his complete knowledge with his direct collaborators and the third strategy the partial-subset where the agents only change part of their own knowledge with her direct collaborators. This strategies give the template for our strategies and implementations.

Knowledge exchange is important in all kinds of MAS and is therefor often use in different ways. For example DEECo \cite{deeco}, SeSaMe \cite{sesame} and DECIDE \cite{decide2015} are frameworks to create multi agent systems. DEECo is self named as an ensemble-based component system where an ensemble represents dynamic binding of a set of components and thus determines their composition and interaction. The ensemble component describes the collaboration and data connection. Although when only some data is used in the other component it proactive share all his information. SeSaMe coordinates distributed components in various selforganizing inter-composed groups based on the types of roles they can play and make a direct interaction between the supervisors and followers. DECIDE splits the control-loops on many nodes of a distributed self-adaptive system. This gives more flexibility and reduces the single point error when a master node fail. The goal of DECIDE is to proof the system at runtime to guarantee the quality requirements of critical self-adaptive software.