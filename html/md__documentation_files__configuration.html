<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SAKE: Configuration</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SAKE
   </div>
   <div id="projectbrief">A Simulation Framework to Analyze Knowledge Exchange Strategies in Distributed Self-adaptive Systems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__documentation_files__configuration.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Configuration </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>We illustrate the results of our simulator based on a specific running example. Three different strategies are used to test and get comparable values for the evaluation. The easiest way is a complete collaboration between each agent. This mean that if an agent meet another agent he gives him his complete local model of the world. To get a higher hierarchical collaboration we use in the other strategies a master agent which handle the communication and makes work decisions.</p>
<p>The environment of the test-case scenario includes different parameters. For example, the size and the nature of the environment change in a different context. Otherwise the dependencies of agent types influence the result of each test-case. To get representative result in each test-case we run it five times and use the average values for the shown diagrams.</p>
<p>The first part of this section contains the running example with different start parameters and agent dependencies and the used strategies. The last parts show the evaluation results based on the time measurement, the energy consumption and the knowledge exchange of a strategy in the different test case scenarios.</p>
<h2>Running Example</h2>
<p>Every company has different building with other structures and characteristics and must clean them every week. Therefor different agents can be used to clean the building after the offices hour. But they have every day the deadline, because they must be finished before the work starts in the morning. The easiest way is to use one agent which must do it alone but it could easily be that he does not finish in time. Then it is important that different agents share the work and communicate about the areas they already clean. Therefor we create three different strategies:</p>
<ol type="1">
<li><p class="startli"><b>Complete Collaboration</b></p>
<p class="startli">Every agent exchange his complete model with a near agent, but with a delay for not always exchange the local model (Configuration 1).</p>
</li>
<li><p class="startli"><b>Communication with Master</b></p>
<p class="startli">A master coordinate and handle the communication with near agents. The master stand at the load-station and exchange the models if the agents are loading. The agent creates his drive destinations on its own information. This approach reduces the local needed memory and minimize the knowledge exchange (Configuration 2).</p>
</li>
<li><p class="startli"><b>Communication and Coordination with Master</b></p>
<p class="startli">The masters always communicate with the agents and say them always what to do. The working agent only need a communication structure and less logic (Configuration 3).</p>
</li>
</ol>
<p>In figure 1 we show the different maps on which we test the three strategies. The centered points in the maps represent the load station and with it the location of the master agent. The first map represents only a big hall, where the probability that two agents met is very high. The second map is a labyrinth which is predefined in Siafu [1]. This is the biggest map we use with a lot of dead end and small ways. In figure 2 the last map represents a floor of the computer science faculty of the TU Dresden. It gives the best real world example with little rooms and big corridors that is why we only show the results from this map. The results of the other maps and agent types are shown in the master thesis [2]. In the maps, each white pixel represents a point which should be cleaned and the black walls show the borders.</p>
<div class="image" align="center"> <div class="image">
<img src="../DocumentationFiles/image/allcards.png" alt="The three test maps" title="Maps" style="width: 700px;"/>
</div>
 <div><b>Fig1. - The three test maps.</b></div> </div><p>To create dependencies between the agent we use three different types of them. Before for example a hoover (vacuum) agent can clean the world he need a map of the area. To realize that a hierarchical structure is used. A master agent communicates with the explore agents about the world and exchange his knowledge with the hoover agents. This three-stage pyramid visualize the agent dependencies. The three steps of the cleaning process are now (a) create the map with explore agents, (b) hoover the area with (hoover) agents and (c) wipe the environment after hooving it with (wipe) agents. This step dependencies mean that every agent need parts of the information from a agent one step before to start with his work. This part brings waiting period for agents from a later step and have influence on the deadline.</p>
<div class="image" align="center"> <div class="image">
<img src="../DocumentationFiles/image/Roboterhierarchie.jpg" alt="Agent dependencies" title="Agent dependencies" style="width: 500px;"/>
</div>
 <div><b>Fig2. - Agent dependencies.</b></div> </div><p>The number of agents influence the deadline too, because of that we decrease first the number of explore agents from one to ten and add then hoover agents and decrease them from one to ten too. This creates a comparable mass of data for conclusion.</p>
<h2>Save local Model</h2>
<p>There are three different ways to save the local model of one agent. First a PNG image which represent the world. Second a CSV Document which shows the world the same way. And at least an XML file to show what Field has which state.</p>
<h2>References</h2>
<table id="qs_table" border="0">
<tr id="Siafu" class="entry">
<td><b>[1]</b> Martin M and Nurmi P (2006), <em>"A Generic Large Scale Simulator for Ubiquitous Computing"</em>, In Third Annual International Conference on Mobile and Ubiquitous Systems: Networking &amp; Services, 2006 (MobiQuitous 2006). San Jose, California, USA, July, 2006. IEEE Computer Society.   </td></tr>
<tr id="W16" class="entry">
<td><b>[2]</b> Werner C (2016), <em>"Adaptive Knowledge Exchange with Distributed Partial Models@Run.time"</em>. Thesis at: Technische Universit&auml;t Dresden., January, 2016.   </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
